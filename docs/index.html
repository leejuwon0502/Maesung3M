<html>
	<head>
		<title>3M</title>
		<meta charset="utf-8" />
		<script src="./test.js"></script>
		<style>
			* { padding: 0; margin: 0; }
			canvas { background: #eee; display: block; margin: 0 auto; }
		</style>
	</head>
	<body>
		<canvas id="Canvas" width="480" height="320"></canvas>
		<script>
			var canvas = document.getElementById("Canvas");
			var ctx = canvas.getContext("2d");
			canvas.width = document.body.clientWidth;
			canvas.height = document.body.clientHeight;
			var Center = { x : canvas.width / 2, y : canvas.height / 2};
			//system
			window.addEventListener("keydown", KeyDown);
			window.addEventListener("keyup", KeyUp);
			window.addEventListener("mousemove", OnMouseMove);
			var OnPress = {};
			var PressedKeys = [];
			let KEYCODES = {
				87 : 'w',
				65 : 'a',
				83 : 's',
				68 : 'd'
			}
			function KeyDown(e) {
				code = KEYCODES[e.keyCode];
				if (!code) {return}
				PressedKeys[code] = OnPress[code];
			}
			function KeyUp(e) {
				delete PressedKeys[KEYCODES[e.keyCode]];
			}
			function OnKey(key, func) {
				OnPress[key] = func;
			}
			MousePos = {
				x : 0,
				y : 0
			}
			function OnMouseMove(e) {
				MousePos.x = e.clientX;
				MousePos.y = e.clientY;
				Light.Position.x = MousePos.x;
				Light.Position.y = MousePos.y;
			}
			OnKey('a', () => {
				Char.Move(-Char.MoveSpeed, 0);
			})
			OnKey('d', () => {
				Char.Move(Char.MoveSpeed, 0);
			})
			OnKey('w', () => {
				Jump();
			})
			OnKey('s', () => {
				console.log(MousePos)
			})
			let ScreenSizeCoef = 50;
			let ScreenSize = { x : 16 * ScreenSizeCoef, y : 9 * ScreenSizeCoef};
			var ClearRectPosition = { x : Center.x - ScreenSize.x / 2, y : Center.y - ScreenSize.y / 2};
			function Render() {
				ctx.clearRect(ClearRectPosition.x, ClearRectPosition.y, ScreenSize.x, ScreenSize.y);
				GameObjectArray.forEach((e) => {
					e.Draw();
				})
			}
			function Update() {
				Debug();
				Controll();
				ApplyPhysics();
				Render();
				requestAnimationFrame(Update);
			}
			function Controll() {
				for(let key in PressedKeys) {
					PressedKeys[key]();
				}
			}
			function GetCollidedArray(Obj) {
				let Arr = [];
				let x, y;
				if (Obj.__proto__.constructor == GameObject) {
					x = Obj.Position.x;
					y = Obj.Position.y;
				}
				else {
					x = Obj[0];
					y = Obj[1];
				}
				GameObjectArray.forEach((e) => {
					// let x = e.DrawInfo.Radius || e.DrawInfo.Width;
					// let y = e.DrawInfo.Radius || e.DrawInfo.Height;
					//x > e.x  
					let ePx = e.Position.x;
					let ePy = e.Position.y;
					let eWidth = e.DrawInfo.Radius || e.DrawInfo.Width;
					let eHeight = e.DrawInfo.Radius || e.DrawInfo.Height;
					if (x > ePx && x < ePx + eWidth && y > ePy && y < ePy + eHeight) {
						Arr.push(e);
					}
				
				})
				return Arr;
			}
			function ApplyPhysics() {
				GameObjectArray.forEach((e) => {
					if (!e.isDynamic) {
						return;
					}
					e.Move(e.Velocity.x, e.Velocity.y);
					//e.Velocity.y += Gravity;
				})
			}
			function GetDrawMethod(ObjC, drawInfo) {
				if (drawInfo.Type == "arc") {
					return () => {
						ctx.beginPath();
						ctx.arc(ObjC.Position.x, ObjC.Position.y, ObjC.DrawInfo.Radius, 0, Math.PI*2);
						ctx.fillStyle = ObjC.DrawInfo.Color;
						ctx.fill();
						ctx.closePath();
					}
				}
				else if (drawInfo.Type == "rect") {
					return () => {
						ctx.beginPath();
						ctx.rect(ObjC.Position.x, ObjC.Position.y, ObjC.DrawInfo.Width, ObjC.DrawInfo.Height);
						ctx.fillStyle = ObjC.DrawInfo.Color;
						ctx.fill();
						ctx.closePath();
					}
				}
			}
			class GameObject {
				constructor(
					positionInfo = [0, 0, "rel"],
					drawInfo,
					moveSpeed = 0
					){
					if (positionInfo[2] == "rel") {
						if (drawInfo.Type == "arc") {
							this.Position = {
								x : Center.x + positionInfo[0],
								y : Center.y + positionInfo[1]
							}
						}
						else {
							let coef = [
								positionInfo[0] / Math.abs(positionInfo[0]),
								positionInfo[1] / Math.abs(positionInfo[1])
							]
							coef[0] |= 1;
							coef[1] |= 1;
							this.Position = {
								x : Center.x + positionInfo[0] - drawInfo.Width / 2,
								y : Center.y + (positionInfo[1] + drawInfo.Height / 2 * coef[1]) - drawInfo.Height / 2
							}
						}
					}
					else {
						this.Position = {
							x : positionInfo[0],
							y : positionInfo[1]
						}
					}
					this.Velocity = {
						x : 0,
						y : 0
					}
					this.DrawInfo = [];
					for(let key in drawInfo) {
						this.DrawInfo[key] = drawInfo[key];
					}
					this.Draw = GetDrawMethod(this, drawInfo);
					this.MoveSpeed = moveSpeed;
					this.isDynamic = moveSpeed != 0;

					GameObjectArray.push(this);
				}
				Move(x = 0, y = 0) {
				 //todo 바닥판정, 물리, 상대적 크기/포지션
					this.Position.x += x;
					this.Position.y += y;
				}
				Draw() {}
			}
			//var, func
			function Debug() {
				
			}
			var JumpHeight = 10;
			var Gravity = 3;
			function Jump() {
				if (Char.Velocity.y == 0) {
					Char.Velocity.y += -JumpHeight;
				}
			}
			function NewBlock(pos, size) {
				return new GameObject(pos, {
					Type : "rect",
					Color : "#FF0000",
					Width : size[0],
					Height : size[1]
				})
			}
			//init
			ctx.fillRect(0, 0, canvas.width, canvas.height); //화면을 검게 한다
			var GameObjectArray = [];
			var Char = new GameObject([0, 0, "rel"], {
				Type : "arc",
				Color : "#0095DD",
				Radius : 10
			}, 5
			);
			Char.Radius = 10;
			var Light = new GameObject(undefined, {
				Type : "arc",
				Color : "rgba(0, 0, 0, 0.1)",
				Radius : 100
			});
			Walls = [
			NewBlock([0, ScreenSize.y / 2, "rel"], [ScreenSize.x, 100]),
			NewBlock([0, -ScreenSize.y / 2, "rel"], [ScreenSize.x, 100]),
			NewBlock([-ScreenSize.x / 2, 0, "rel"], [100, ScreenSize.y]),
			NewBlock([ScreenSize.x / 2, 0, "rel"], [100, ScreenSize.y])
			]
			//Light.draw //todo 빛
			//code
			
			//repeat
			Update();
		</script>
	</body>
</html>

